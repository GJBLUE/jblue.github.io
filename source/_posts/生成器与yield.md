---
title: 生成器与yield
date: 2017-03-07 12:59:26
tags: [生成器, yield]
categories: Python
---

> 在聊生成器之前，必须要说一说什么是可迭代对象。在 Python 中，所有集合都可以迭代。而序列可以迭代的原因，则依赖于iter函数的实现。  

<!--more-->

## 可迭代对象的机制(引用自《fluent python》)

解释器需要迭代对象x时，会自动调用iter(x)。需要注意的是，可迭代对象不等于迭代器。内置的 iter 函数有以下作用：
1. 检查对象是否实现了 **__iter__** 方法，如果实现了就调用它，获取一个迭代器。
2. 如果没有实现 __iter__ 方法，但是实现了 __getitem__ 方法，Python 会创建一个迭代器，尝试按顺序(从索引 0 开始)获取元素。
3. 如果尝试失败，Python抛出TypeError异常，通常会提示“C object is not iterable”(C对象不可迭代)，其中 C 是目标对象所属的类。
iter()有个实用例子，逐行读取文件，直到遇到空行或者到达文件末尾为止：
```python
with open('mydata.txt') as fp:
    for line in iter(fp.readline, ''):
        process_line(line)
```

## 可迭代对象和迭代器(引用自《fluent python》)
**可迭代的对象**：
    使用 iter 内置函数可以获取迭代器的对象。如果对象实现了能返回迭代器的 __iter__ 方法，那么对象就是可迭代的。序列都可以迭代;实现了 __getitem__ 方法，而且其参 数是从零开始的索引，这种对象也可以迭代。
**迭代器**:
    迭代器是这样的对象:实现了无参数的 __next__ 方法，返回序列中的下一个元素;如果没有元素了，那么抛出 StopIteration 异常。Python中的迭代器还实现了 __iter__ 方 法，因此迭代器也可以迭代。简单来说，迭代器只需 __next__ 和 __iter__ 两个方法。  

## 生成器

首先，生成器(Generator)是一个函数，它会生成一个可迭代的对象。所有生成器都是迭代器，因为生成器完全实现了迭代器接口。和列表最大的区别在于，生成器可以在迭代的过程中一边循环一边计算，不必像列表那般创建完整的序列，从而节省内存空间。 其次就是创建完生成器后，它会返回一个生成器对象，这个生成器对象使用next()进行调用。定义方面生成器和列表的区别就是用()代替[]，一样可以用推导式。
``` python
In [1]: g = (i for i in range(5))  # 创建一个生成器
In [2]: g
Out[2]: <generator object <genexpr> at 0x10c3605f0>
In [5]: g.next()
Out[5]: 0
In [6]: g.next()
Out[6]: 1
...
```
此处需要注意的问题是数组下标越界问题，当然一般使用可以借助for循环。生成器也提供了close()方法，可以主动进行关闭(通常不必手动调用的)。

## yield

函数使用yield关键字可以生成一个生成器对象，这也是生成器的常规使用方式。生成器在调用next()方法时，生成器会不断地执行语句，直到执行到yield语句为止。yield语句在此时返回一个结果，然后继续执行yield之后的语句。

``` python
In [1]: def func(n):
  ....:     for i in range(n):
  ....:         yield i

In [2]: res = func(3)

In [3]: for i in res:
   ....:     print i

```
这里需要理解的是，调用函数的时候,函数里的代码并没有运行。函数仅仅返回生成器对象，即res。当for语句迭代生成器返回生成器对象时，函数func里的代码才开始执行，直到碰到yield。


