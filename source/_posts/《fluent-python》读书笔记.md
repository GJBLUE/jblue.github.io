---
title: 《fluent python》读书笔记
date: 2017-07-09 16:52:52
tags: Python
categories: 读书笔记
---
> 《fluent python》是本好书，本书中提到了不少东西，都是自己之前忽视或者说只知其然。自己在阅读的时候经常有种“哇”的感觉，在此撂作一点积累，毕竟现在还是偷了的知识，算不得自己，且走且行。  

<!--more-->

1. 序列类型
    容器序列： list、tuple 和 collections.deque 这些序列能存放不同类型的数据。
    扁平序列：str、bytes、bytearray、memoryview 和array.array，这类序列只能容纳一种类型。
    可变序列：list、bytearray、array.array、collections.deque 和 memoryview。
    不可变序列：tuple、str 和 bytes。    容器序列存放的是**它们所包含的任意类型的对象的引用**，而扁平序列里存放的是**值而不是引用**。换句话说，扁平序列其实是一段连续的内存空间。由此可见扁平序列其实更加紧 凑，但是它里面只能存放诸如字符、字节和数值这种基础类型。    
2. 字典中的散列表：
    散列表其实是一个稀疏数组(总是有空白元素的数组称为稀疏数组)。     在一般的数据结构 教材中，散列表里的单元通常叫作表元(bucket)。在 dict 的散列表当中，每个键值对都 占用一个表元，每个表元都有两个部分，一个是对键的引用，另一个是对值的引用。因为 所有表元的大小一致，所以可以通过偏移量来读取某个表元。
3. 装饰器的一个关键特性是，它们在被装饰的函数定义之后立即运行。这通常是在导入时(即Python加载模块时)。也就是有部分操作可以借由此特性来实现。
4. *functools.lru_cache*，这是一项优化技术，它把耗时的函数的结果保存起来，避免传入相同的参数时重复计算。
5. 弱引用不会增加对象的引用数量。引用的目标对象称为所指对象(referent)。因此我们说，弱引用不会妨碍所指对象被当作垃圾回收。
6. 每个Python对象都有标识、类型和值。只有对象的值会不时变化。
7. 在模块中，顶层名称使用一个前导下划线的话，的确会有影响:对from mymod import * 来说，mymod中前缀为下划线的名称不会被导入。然而，依旧可以使用from mymod import _privatefunc 将其导入。
8. dir(slice)得到的结果中有个indices属性：**S.indices(len)->(start, stop, stride)**，即给定长度为 len 的序列，计算 S 表示的扩展切片的起始(start)和结尾(stop)索引，以及步幅(stride)。超出边界的索引会被截掉，这与常规切片的处理方式一样。
    ```python
    >>> slice(None, 10, 2).indices(5)  # 等同于[0:5:2]
    (0, 5, 2)
    >>> slice(-3, None, None).indices(5)  # 等同于[2:5:1]    
    (2, 5, 1)
    ```
9. **__getattr__**的运作方式：当对象没有指定名称的属性时，Python 才会调用这个方法，这是一种后备机制。可是，像 v.x = 10 这样赋值之 后，v 对象有 x 属性了，因此使用 v.x 获取 x 属性的值时不会调用 __getattr__ 方法了，解 释器直接返回绑定到 v.x 上的值，即 10。另一方面，__getattr__ 方法的实现没有考虑到当前实例之外的实例属性，而是从这个属性中获取 shortcut_names 中所列的“虚拟属性”。
10. 解释器需要迭代对象x时，会自动调用iter(x)。任何 Python 序列都可迭代的原因是，它们都实现了**__getitem__**方法。其实，标准的序列也都实现了**__iter__**方法，因此你也应该这么做。之所以对**__getitem__**方法做特殊处理，是为了向后兼容，而未来可能不会再这么做。
11. 期物指一种对象，表示异步执行的操作。通常我们需要的是期望所带来的结果。
12. 避免使用可变的对象作为参数的默认值，默认值在定义函数时计算(通常在加载模块时)，因此默认值变成了函数对象的属性。因此，如果默认值是可变对象(如list)，而且修改了它的值，那么后续的函数调用都会受到影响。
13. 在Python中，数据的属性和处理数据的方法统称属性(attribute)。其实，**方法只是可调用的属性**。除了这二者之外，我们还可以创建特性(property)，在不改变类接口的前提下， 使用存取方法(即读值方法和设值方法)修改数据属性。这与统一访问原则相符: **不管服务是由存储还是计算实现的，一个模块提供的所有服务都应该通过统一的方式使用。**
14. 影响属性处理方式的特殊属性
    **__class__**： 对象所属类的引用(即 obj.__class__ 与 type(obj) 的作用相同)。Python   的某些特殊方法，例如 __getattr__，只在对象的类中寻找，而不在实例中寻找。  
    **__dict__**： 一个映射，存储对象或类的可写属性。有 __dict__ 属性的对象，任何时候都能随意                        设置新属性。如果类有 __slots__ 属性，它的实例可能没有 __dict__ 属性。参见下面对 __slots__ 属性的说明。  
    **__slots__**： 类可以定义这个这属性，限制实例能有哪些属性。__slots__ 属性的值是一个字符串组成的元组，指明允许有的属性。如果 __slots__ 中没有 '__dict__'，那么该类的实例 没有 __dict__ 属性，实例只允许有指定名称的属性。  
15. 描述符是实现了特定协议的类，这个协议包括 __get__、__set__ 和 __delete__ 方法。 比如property类就实现了完整的描述符协议。描述符的用法是，创建一个实例，作为另一个类的类属性。


